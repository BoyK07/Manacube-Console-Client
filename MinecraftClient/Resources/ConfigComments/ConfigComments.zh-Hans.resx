<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata" id="root">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace"/>
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0"/>
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string"/>
              <xsd:attribute name="type" type="xsd:string"/>
              <xsd:attribute name="mimetype" type="xsd:string"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string"/>
              <xsd:attribute name="name" type="xsd:string"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1"/>
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3"/>
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4"/>
              <xsd:attribute ref="xml:space"/>
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1"/>
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required"/>
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="AppVars.Variables" xml:space="preserve">
    <value>可以在某些字段中以 "%yourvar%" 的形式使用。
%username% 和 %serverip% 为保留的变量名。</value>
  </data>
  <data name="ChatBot" xml:space="preserve">
    <value>=============================== #
Minecraft 控制台客户端 机器人  #
=============================== #</value>
  </data>
  <data name="ChatBot.Alerts" xml:space="preserve">
    <value>当检测到特定聊天消息或特定事件发生时提醒你
 # 对检测特定玩家的聊天消息很有用。</value>
  </data>
  <data name="ChatBot.Alerts.Beep_Enabled" xml:space="preserve">
    <value>除了高亮显示外，当检测到一个词时还会播放类似蜂鸣器的哔哔声。</value>
  </data>
  <data name="ChatBot.Alerts.Excludes" xml:space="preserve">
    <value>出现这些关键词后该条消息一定不触发提醒。</value>
  </data>
  <data name="ChatBot.Alerts.Log_File" xml:space="preserve">
    <value>日志文件的路径。</value>
  </data>
  <data name="ChatBot.Alerts.Log_To_File" xml:space="preserve">
    <value>是否将提醒消息写入到日志文件。</value>
  </data>
  <data name="ChatBot.Alerts.Matches" xml:space="preserve">
    <value>触发提醒的聊天关键词列表。</value>
  </data>
  <data name="ChatBot.Alerts.Trigger_By_Rain" xml:space="preserve">
    <value>在开始下雨和停止下雨时触发提醒。</value>
  </data>
  <data name="ChatBot.Alerts.Trigger_By_Thunderstorm" xml:space="preserve">
    <value>在雷暴天气的开始与结束触发提醒。</value>
  </data>
  <data name="ChatBot.Alerts.Trigger_By_Words" xml:space="preserve">
    <value>在收到指定的关键词后触发提醒。</value>
  </data>
  <data name="ChatBot.AntiAfk" xml:space="preserve">
    <value>定期发送命令，或让机器人随机走动，以避免检测到挂机后被踢出服务器
 # /!\启用前请确保你的服务器规则不禁止反AFK机制！
/!\如果启用随机移动，请将机器人围在围栏里，以防走失！（建议尺寸5x5x5）</value>
  </data>
  <data name="ChatBot.AntiAfk.Command" xml:space="preserve">
    <value>发送给服务器的指令。</value>
  </data>
  <data name="ChatBot.AntiAfk.Delay" xml:space="preserve">
    <value>执行操作的间隔时间。（秒）</value>
  </data>
  <data name="ChatBot.AntiAfk.Use_Sneak" xml:space="preserve">
    <value>在发送命令时是否蹲下。</value>
  </data>
  <data name="ChatBot.AntiAfk.Use_Terrain_Handling" xml:space="preserve">
    <value>启用地形处理，以使机器人能够四处移动。</value>
  </data>
  <data name="ChatBot.AntiAfk.Walk_Range" xml:space="preserve">
    <value>机器人可以随机移动的范围（注意：范围越大，速度越慢）</value>
  </data>
  <data name="ChatBot.AntiAfk.Walk_Retries" xml:space="preserve">
    <value>尝试移动失败几次后在改为发送命令模式。</value>
  </data>
  <data name="ChatBot.AutoAttack" xml:space="preserve">
    <value>自动攻击周围的生物
使用此功能之前，你需要开启实体处理。
/!\确保你的服务器允许使用自动攻击。
/!\服务器插件可能会认为此功能时作弊，并可能会封禁你的账号，所以请自己检查服务器规则是否允许。</value>
  </data>
  <data name="ChatBot.AutoAttack.Attack_Hostile" xml:space="preserve">
    <value>是否攻击敌对生物。</value>
  </data>
  <data name="ChatBot.AutoAttack.Attack_Passive" xml:space="preserve">
    <value>是否攻击被动生物。</value>
  </data>
  <data name="ChatBot.AutoAttack.Attack_Range" xml:space="preserve">
    <value>上限介于 1 到 4</value>
  </data>
  <data name="ChatBot.AutoAttack.Cooldown_Time" xml:space="preserve">
    <value>每次攻击间的冷却时间，设置 "Custom = false" 以让MCC自动计算攻击速度。</value>
  </data>
  <data name="ChatBot.AutoAttack.Entites_List" xml:space="preserve">
    <value>你可以在这里找到所有的实体名称：https://mccteam.github.io/r/entity/#L15</value>
  </data>
  <data name="ChatBot.AutoAttack.Interaction" xml:space="preserve">
    <value>可选项："Interact"（交互），"Attack"（攻击） 或 "InteractAt"（交互并攻击）</value>
  </data>
  <data name="ChatBot.AutoAttack.List_Mode" xml:space="preserve">
    <value>将实体列表作为 "whitelist"（白名单）还是 "blacklist"（黑名单）。</value>
  </data>
  <data name="ChatBot.AutoAttack.Mode" xml:space="preserve">
    <value>"single"（单目标） 或 "multi"（多目标）。一次攻击一个生物还是范围内的所有生物。</value>
  </data>
  <data name="ChatBot.AutoAttack.Priority" xml:space="preserve">
    <value>"health"（生命值）或 "distance"（距离）。当使用"single"模式时，以哪一个属性确定优先级。</value>
  </data>
  <data name="ChatBot.AutoCraft" xml:space="preserve">
    <value>自动使用背包中的物品进行合成。
请看 https://mccteam.github.io/g/bots/#auto-craft
你需要启用库存处理来使用这个功能
如果需要使用工作台，你还需要启用地形处理。</value>
  </data>
  <data name="ChatBot.AutoCraft.CraftingTable" xml:space="preserve">
    <value>如果你打算使用工作台，请填写它所在的位置。（需要启用地形处理）</value>
  </data>
  <data name="ChatBot.AutoCraft.OnFailure" xml:space="preserve">
    <value>合成失败时应该怎么处理，"abort"（中止）或 "wait"（等待）。</value>
  </data>
  <data name="ChatBot.AutoCraft.Recipes" xml:space="preserve">
    <value>Recipes.Name：给该配方起一个独一无二的名字。（不能包含空白字符）
Recipes.Type：合成类型，"player"（背包2x2）或 "table"（工作台3x3）
Recipes.Result：合成的目标物品
Recipes.Slots：合成的物品摆放方式，以从左到右、从上到下的格式填写。需留空请填写"Null"
最新的物品命名请看：https://mccteam.github.io/r/item/#L12</value>
  </data>
  <data name="ChatBot.AutoDig" xml:space="preserve">
    <value>自动挖掘方块。
你需要启用地形处理来使用这个功能。
你可以使用 "/digbot start" 和 "/digbot stop" 指令来控制 AutoDig 的启停。
由于MCC目前还不支持精确计算方块的碰撞体积，在获取看向的方块时，视线上所有的方块都被看作是完整的立方体。
查询方块的名称，请访问 https://mccteam.github.io/r/block/#L15</value>
  </data>
  <data name="ChatBot.AutoDig.Auto_Start_Delay" xml:space="preserve">
    <value>进入游戏后等待多少秒后开始自动挖掘，设置为-1禁用自动开始。</value>
  </data>
  <data name="ChatBot.AutoDig.Auto_Tool_Switch" xml:space="preserve">
    <value>自动切换到合适的工具。</value>
  </data>
  <data name="ChatBot.AutoDig.Dig_Timeout" xml:space="preserve">
    <value>若挖掘一个方块用时超过这个值，将会重新获取目标进行挖掘。</value>
  </data>
  <data name="ChatBot.AutoDig.Drop_Low_Durability_Tools" xml:space="preserve">
    <value>在当前使用的工具耐久度过低后，是否丢掉它。</value>
  </data>
  <data name="ChatBot.AutoDig.Durability_Limit" xml:space="preserve">
    <value>不会使用低于此耐久度的工具。（需要启用库存处理）</value>
  </data>
  <data name="ChatBot.AutoDig.List_Type" xml:space="preserve">
    <value>将方块列表作为 "whitelist"（白名单）还是 "blacklist"（黑名单）。</value>
  </data>
  <data name="ChatBot.AutoDig.Locations" xml:space="preserve">
    <value>使用 "fixedpos" 或 "both" 模式时，方块的坐标。</value>
  </data>
  <data name="ChatBot.AutoDig.Location_Order" xml:space="preserve">
    <value>"distance" 或 "index"，当使用 "fixedpos" 模式时，按照到玩家的距离，还是列表中的顺序确定挖掘的方块。</value>
  </data>
  <data name="ChatBot.AutoDig.Log_Block_Dig" xml:space="preserve">
    <value>是否输出挖掘方块的相关信息。</value>
  </data>
  <data name="ChatBot.AutoDig.Mode" xml:space="preserve">
    <value>"lookat"，"fixedpos" 或 "both"。挖掘看向的方块还是固定位置的方块，或者是两个条件都满足的方块。</value>
  </data>
  <data name="ChatBot.AutoDrop" xml:space="preserve">
    <value>自动从背包/库存中丢弃指定的物品
你需要启用库存处理来使用这个功能
查询物品命名：https://mccteam.github.io/r/item/#L12</value>
  </data>
  <data name="ChatBot.AutoDrop.Mode" xml:space="preserve">
    <value>"include"（丢弃列表中的物品），"exclude"（丢弃列表外的所有物品） 或 "everything"（丢弃所有物品）</value>
  </data>
  <data name="ChatBot.AutoEat" xml:space="preserve">
    <value>在饱食度较低是自动在背包中寻找食物食用。
你需要启用库存处理来使用这个功能。</value>
  </data>
  <data name="ChatBot.AutoFishing" xml:space="preserve">
    <value>使用鱼竿自动钓鱼。
指南：https://mccteam.github.io/g/bots/#auto-fishing
你可以使用"/fish"命令来手动进行控制。
/!\ 启用前请确保服务器允许你自动钓鱼。</value>
  </data>
  <data name="ChatBot.AutoFishing.Antidespawn" xml:space="preserve">
    <value>如果你之前没有启用过这个选项，请保持它为 false 。</value>
  </data>
  <data name="ChatBot.AutoFishing.Auto_Rod_Switch" xml:space="preserve">
    <value>在当前鱼竿不可用后自动切换到背包中的其他鱼竿。（需要启用库存处理）</value>
  </data>
  <data name="ChatBot.AutoFishing.Auto_Start" xml:space="preserve">
    <value>是否在进入服务器后自动开始钓鱼，禁用此功能后，你需要使用"/usehand"手动使用鱼竿一次。</value>
  </data>
  <data name="ChatBot.AutoFishing.Cast_Delay" xml:space="preserve">
    <value>钓到鱼后多久开始下一次钓鱼（抛竿）。</value>
  </data>
  <data name="ChatBot.AutoFishing.Durability_Limit" xml:space="preserve">
    <value>不会使用低于此耐久度的鱼竿（鱼竿耐久度最高为64）。（需要启用库存处理）</value>
  </data>
  <data name="ChatBot.AutoFishing.Enable_Move" xml:space="preserve">
    <value>这允许玩家在钓到鱼后改变其位置或朝向。（需要启用地形处理）</value>
  </data>
  <data name="ChatBot.AutoFishing.Fishing_Delay" xml:space="preserve">
    <value>进入服务器后多久后开始自动钓鱼。（秒）</value>
  </data>
  <data name="ChatBot.AutoFishing.Fishing_Timeout" xml:space="preserve">
    <value>多少秒后没有钓到鱼视为超时。超时后会重新抛竿。</value>
  </data>
  <data name="ChatBot.AutoFishing.Hook_Threshold" xml:space="preserve">
    <value>一个“静止”的鱼钩，在Y轴方向上的移动超过这个阈值将被认为钓到了鱼。</value>
  </data>
  <data name="ChatBot.AutoFishing.Log_Fish_Bobber" xml:space="preserve">
    <value>用于调整以上两个阈值，启用后会在收到鱼钩实体移动数据包后打印其坐标变化。</value>
  </data>
  <data name="ChatBot.AutoFishing.Mainhand" xml:space="preserve">
    <value>使用主手还是副手拿鱼竿。</value>
  </data>
  <data name="ChatBot.AutoFishing.Movements" xml:space="preserve">
    <value>会按照 "1-&gt;2-&gt;3-&gt;4-&gt;3-&gt;2-&gt;1-&gt;2-&gt;..." 的顺序执行。每次可用改变位置、朝向或是都改变。推荐只改变朝向。</value>
  </data>
  <data name="ChatBot.AutoFishing.Stationary_Threshold" xml:space="preserve">
    <value>鱼钩在X轴和Z轴方向上的移动小于这个值将被认为是静止的，过高的阈值会在抛竿途中触发收竿。</value>
  </data>
  <data name="ChatBot.AutoRelog" xml:space="preserve">
    <value>在被服务器断开连接时自动重连，例如服务器重启时。
/!\ 谨慎使用Ignore_Kick_Message=true，这会在服务器管理员将你踢出时依然连回！</value>
  </data>
  <data name="ChatBot.AutoRelog.Delay" xml:space="preserve">
    <value>重新加入到服务器前的延迟时间。(单位：秒)</value>
  </data>
  <data name="ChatBot.AutoRelog.Ignore_Kick_Message" xml:space="preserve">
    <value>当设置为 true 时，将不考虑踢出的信息直接重连。</value>
  </data>
  <data name="ChatBot.AutoRelog.Kick_Messages" xml:space="preserve">
    <value>如果踢出信息与这其中的任何一个字符串匹配，那么将触发自动重连。</value>
  </data>
  <data name="ChatBot.AutoRelog.Retries" xml:space="preserve">
    <value>重新登录服务器失败时的重试次数，使用-1表示无限重试。</value>
  </data>
  <data name="ChatBot.AutoRespond" xml:space="preserve">
    <value>当聊天消息与文件中的规则匹配时，自动执行指定命令。
/!\ 服务器管理员可以以任意玩家的身份发送任意消息，记住这一点！
此机器人如果设置的不得当可能会造成刷屏，建议设置一个冷却时间。</value>
  </data>
  <data name="ChatBot.AutoRespond.Match_Colors" xml:space="preserve">
    <value>不要删除文本中的颜色代码（使用§字符的代码）。注意：启用后你的匹配模板也必须包括颜色代码。</value>
  </data>
  <data name="ChatBot.ChatLog" xml:space="preserve">
    <value>将聊天信息写入到日志文件中。</value>
  </data>
  <data name="ChatBot.DiscordBridge" xml:space="preserve">
    <value>此机器人允许您通过Discord频道发送和接收消息和命令。
您也可以在文档中阅读此机器人的配置方法(文档中有图像)。
文档：https://mccteam.github.io/g/bots/#discord-bridge
配置方法：
首先您需要在 Discord 开发者中心上创建一个机器人，这有一个视频教程：https://www.youtube.com/watch?v=2FgMnZViNPA。
/!\ 重要/! : 创建机器人时，您必须启用"Message Content Intent"，"Server Members Intent"和"Presence Intent"才能使机器人工作！还请小心跟随教程，不要错过任何步骤！
创建机器人时，复制生成的令牌并将其粘贴在"Token"字段中 (令牌很重要，保证它们的安全)。
复制"Application ID"并访问：https://discordapi.com/permissions.html
粘贴您复制过的ID并在权限中检查"Administrator"字段，然后点击底部的链接。
这将打开您的服务器的邀请菜单，选择您想邀请机器人的服务器并邀请他。
邀请机器人后，前往您的Discord客户端访问设置 -&gt; 高级并启用"Developer Mode"。
退出设置并右击邀请机器人进入服务器列表中的服务器 然后点击"Copy ID"，然后将ID粘贴到下方的"GuildId"。
然后右键单击要与机器人互动的频道，然后右键单击选择&gt; "Copy ID"，然后将ID粘贴到下方的"ChannelId"。
最后，在频道发送一条消息， 右键单击你的昵称，然后右键单击选择&gt; "Copy ID"，然后将ID粘贴到下方的"OwnersIds"。
-----------------------------------------------------------
如何使用：
希望运行MCC指令时，在指令前加上点 "."。例如 ".move 143 64 735"。
希望发送聊天信息时，只需要直接发送就好了。</value>
  </data>
  <data name="ChatBot.DiscordBridge.ChannelId" xml:space="preserve">
    <value>你想要使机器人与 MCC 交互的频道ID。</value>
  </data>
  <data name="ChatBot.DiscordBridge.Formats" xml:space="preserve">
    <value>消息格式
使用 { 和 } 包裹的单词将在代码执行过程中被替换，请不要更改它们！
例如，{message} 将替换为实际的消息，{username} 将替换为用户名， {timestamp} 将替换为当前时间。
了解Discord消息格式，请访问：https://mccteam.github.io/r/dc-fmt.html</value>
  </data>
  <data name="ChatBot.DiscordBridge.GuildId" xml:space="preserve">
    <value>你邀请机器人加入的服务器ID。</value>
  </data>
  <data name="ChatBot.DiscordBridge.MessageSendTimeout" xml:space="preserve">
    <value>如果信息无法被发送至Discord时，要等候多少秒才取消发送。（最小 1 秒）</value>
  </data>
  <data name="ChatBot.DiscordBridge.OwnersIds" xml:space="preserve">
    <value>你希望能够使用机器人与 MCC 交互的用户ID列表。</value>
  </data>
  <data name="ChatBot.DiscordBridge.Token" xml:space="preserve">
    <value>你的Discord机器人的令牌。</value>
  </data>
  <data name="ChatBot.Farmer" xml:space="preserve">
    <value>自动为你耕种农作物（种下，收获和骨粉催熟）
可用的农作物类型：Beetroot（甜菜根）, Carrot（萝卜）, Melon（西瓜）, Netherwart（地狱疣）, Pumpkin（南瓜）, Potato（马铃薯）, Wheat（小麦）
使用方法："/farmer start" 指令和 "/farmer stop" 指令。
注意：这是新加入的机器人，它不完美并且只在 1.19.2 版本进行过测试。它有些小问题，例如有时候不能对萝卜或马铃薯使用骨粉催熟；
或机器人会在耕地上跳跃并破坏耕地（这很少发生，但还是有机率出现）。我们期待可以改善它。
另外，如果你的耕地只有一格厚，请加厚至两格以上，否则机器人在重新连接时有可能会穿过耕地并掉落。
此外，如果机器人走到边缘时将不会拾起所有的掉落物，我们已有计划在未来添加这个选项，同时加入将农作物放到箱子及从箱子补充骨粉。</value>
  </data>
  <data name="ChatBot.Farmer.Delay_Between_Tasks" xml:space="preserve">
    <value>任务之间的延迟时间（最短为1秒）</value>
  </data>
  <data name="ChatBot.FollowPlayer" xml:space="preserve">
    <value>让机器人跟随指定玩家
注意这是一个实验性的功能，目前的寻路速度可能很慢，你可能需要时常等一会机器人来让它跟上你。
你可以调整"Update_Limit"，找到最适合你的速度。（注意不要设置的太低，这样可能导致反效果或使MCC卡顿）。
/!\ 在使用此功能之前，请先确保服务器规则允许你这样做。</value>
  </data>
  <data name="ChatBot.FollowPlayer.Stop_At_Distance" xml:space="preserve">
    <value>如果玩家在该范围内，则视为已经接近玩家了。（防止机器人将玩家推开而产生无限循环）</value>
  </data>
  <data name="ChatBot.FollowPlayer.Update_Limit" xml:space="preserve">
    <value>机器人寻路的间隔时间（以秒为单位）</value>
  </data>
  <data name="ChatBot.HangmanGame" xml:space="preserve">
    <value>一个用于演示聊天互动的小游戏。玩家可以一次一个字母地猜出神秘的单词。
你需要正确地使用 ChatFormat，并在 botowners 中添加自己，用/tell &lt;bot username&gt; start
/!\ 这个机器人可能会造成刷屏，如果许多玩家与它互动。</value>
  </data>
  <data name="ChatBot.Mailer" xml:space="preserve">
    <value>在玩家和服务器之间中继消息，就像一个邮件插件一样。
这个机器人可以在收件人离线时存储消息，并在他们加入服务器时发送消息。
/!\ 服务器管理员可以以任意玩家的身份发送任意消息，请记住这一点。</value>
  </data>
  <data name="ChatBot.Map" xml:space="preserve">
    <value>允许你将地图渲染成.jpg图片，该图片会被渲染到Rendered_Maps文件夹中。
注意：这个功能目前只对解决使用地图的验证码有用。
如果一些服务器解决验证码的时间很短，请启用Auto_Render_On_Update并准备快速打开该文件。
在linux上，你可以使用FTP来访问生成的文件。</value>
  </data>
  <data name="ChatBot.Map.Auto_Render_On_Update" xml:space="preserve">
    <value>一旦接收到新的地图或已有地图被更新，自动渲染该地图。</value>
  </data>
  <data name="ChatBot.Map.Delete_All_On_Unload" xml:space="preserve">
    <value>在卸载/重新加载地图时删除所有已渲染的地图（退出MCC时不会删除图像）</value>
  </data>
  <data name="ChatBot.Map.Notify_On_First_Update" xml:space="preserve">
    <value>当第一次从服务器上收到一张地图时，发送一个通知。</value>
  </data>
  <data name="ChatBot.Map.Rasize_Rendered_Image" xml:space="preserve">
    <value>调整渲染图像的大小，当渲染的图像较小或需要发送到Discord时，这很有用。</value>
  </data>
  <data name="ChatBot.Map.Render_In_Console" xml:space="preserve">
    <value>是否在控制台中渲染地图。</value>
  </data>
  <data name="ChatBot.Map.Resize_To" xml:space="preserve">
    <value>渲染的图像应调整到的大小，以像素为单位（例如 512）。</value>
  </data>
  <data name="ChatBot.Map.Save_To_File" xml:space="preserve">
    <value>是否将地图保存为文件。</value>
  </data>
  <data name="ChatBot.Map.Send_Rendered_To_Bridges" xml:space="preserve">
    <value>将已渲染地图（保存到文件）通过Discord/Telegram Bridge发送到Discord/Telegram频道（Discord/Telegram Bridge必须已激活并完成配置！）
你需要激活 Save_To_File 才能使用此功能。
我们同时建议打开调整大小功能。</value>
  </data>
  <data name="ChatBot.PlayerListLogger" xml:space="preserve">
    <value>定期记录当前的玩家列表到文件中。</value>
  </data>
  <data name="ChatBot.PlayerListLogger.Delay" xml:space="preserve">
    <value>（单位：秒）</value>
  </data>
  <data name="ChatBot.RemoteControl" xml:space="preserve">
    <value>通过游戏中的私聊向机器人发送MCC控制台命令
你需要先配置好[ChatFormat]章节的设置，并在[Main.Advanced.bot_owners]中添加自己的账号。
/!\ 服务器管理员可以以任意玩家的身份发送任意消息，仅在信任他们时启用本功能。</value>
  </data>
  <data name="ChatBot.ReplayCapture" xml:space="preserve">
    <value>使用"/replay start"开始记录游戏，并在之后使用 Replay Mod (https://www.replaymod.com/) 进行重放。
请注意，由于技术限制，玩家自身不会显示在重放文件中。
/!\ 你应该使用"/replay stop"停止记录或者使用"/quit"退出程序，否则回放文件可能会损坏。</value>
  </data>
  <data name="ChatBot.ReplayCapture.Backup_Interval" xml:space="preserve">
    <value>每间隔多少秒自动保存一次回放文件，以秒为单位。使用-1禁用自动保存。</value>
  </data>
  <data name="ChatBot.ScriptScheduler" xml:space="preserve">
    <value>在加入服务器时、到达特定时间时或以设定的时间间隔执行命令或脚本文件
详细使用方法请查看：https://mccteam.github.io/g/bots/#script-scheduler</value>
  </data>
  <data name="ChatBot.TelegramBridge" xml:space="preserve">
    <value>这个 Chatbot 可以让你通过Telegram机器人使用Telegram频道或私聊来与MCC交互。
/!\ 注意：你不能从群组对话发送信息和指令，你只能从私人信息发送，但你可以从客户端取得群组对话的信息。
-----------------------------------------------------------
配置：
首先你需要创建一个Telegram机器人并取得API密钥。请到Telegram找到@botfather
点击开始按钮，阅读机器人的信息，然后输入 "/newbot"。@botfather 将会引导你创建机器人。
当成功创建机器人后，复制API钥匙，然后贴在 "ChatBot.TelegramBridge" 部分中的 "Token" 字段（本部分）
/!\ 请勿与任何人分享API密钥，并将它存储在安全的地方。
然后启动客户端和你的Telegram，在Telegram中寻找你新创建的机器人并与机器人打开私人信息。
点击开始按钮，输入并发送 ".chatid" 指令来获得聊天室ID。
复制聊天室ID （例子：2627844670），然后贴在 "ChannelId" 字段和 "Authorized_Chat_Ids" 字段 （"Authorized_Chat_Ids" 字段是一个数字而不是字符串），存储配置文档。
现在你可以通过私聊信息来使用机器人。
/!\ 如果你没有将聊天室ID加到 "Authorized_Chat_Ids" 字段，任何找到你的机器人的人将能够运行指令和发送信息！
/!\ "Authorized_Chat_Ids" 字段中的ID应该是一个数字而不是字符串！
-----------------------------------------------------------
注意：如果你希望通过群组来接收信息，将群组暂时改为公开，邀请你的机器人到群组并给与机器人管理员权限，最后将群组改为私人。
然后将 "ChannelId" 字段设为 @群组名称（必须包括@，例子："@mysupersecretchannel"），你可以在频道邀请链接看到这个用户名。
/!\ 只需包含用户名加上@在前面，不需要包括剩下的链接。例如你的链接是 "https://t.me/mysupersecretchannel"，"ChannelId" 字段将会是 "@mysupersecretchannel"。
/!\ 注意，你将不能从群组发送信息到客户端！
-----------------------------------------------------------
如何使用：
希望运行MCC指令时，在指令前加上点 "."。例如 ".move 143 64 735"。
希望发送聊天信息时，只需要直接发送就好了。</value>
  </data>
  <data name="ChatBot.TelegramBridge.Authorized_Chat_Ids" xml:space="preserve">
    <value>允许发送信息和运行指令的聊天室ID列表。要获得你的私人聊天室ID，请在 Telegram 中使用 ".chatid" 指令。</value>
  </data>
  <data name="ChatBot.TelegramBridge.ChannelId" xml:space="preserve">
    <value>你想要使机器人与 MCC 交互的频道ID。</value>
  </data>
  <data name="ChatBot.TelegramBridge.Formats" xml:space="preserve">
    <value>消息格式
使用 { 和 } 包裹的单词将在代码执行过程中被替换，请不要更改它们！
例如，{message} 将替换为实际的消息，{username} 将替换为用户名， {timestamp} 将替换为当前时间。
了解Telegram消息格式，请访问：https://mccteam.github.io/r/tg-fmt.html</value>
  </data>
  <data name="ChatBot.TelegramBridge.MessageSendTimeout" xml:space="preserve">
    <value>如果信息无法被发送至Telegram时，要等候多少秒才取消发送。（最小 1 秒）</value>
  </data>
  <data name="ChatBot.TelegramBridge.Token" xml:space="preserve">
    <value>你的Telegram机器人的令牌。</value>
  </data>
  <data name="ChatFormat" xml:space="preserve">
    <value>MCC会尽力检测聊天信息，但有些服务器有不寻常的聊天格式
当这种情况发生时，你需要在下面自定义匹配聊天所用的正则表达式
详见 https://mccteam.github.io/g/conf/#chat-format-section</value>
  </data>
  <data name="ChatFormat.Builtins" xml:space="preserve">
    <value>是否启用MCC内置的聊天检测规则。设置为 false 以避免与自定义格式冲突。</value>
  </data>
  <data name="ChatFormat.UserDefined" xml:space="preserve">
    <value>是否启用下方的自定义正则表达式进行聊天检测。</value>
  </data>
  <data name="Console" xml:space="preserve">
    <value>与控制台相关的设置</value>
  </data>
  <data name="Console.CommandSuggestion" xml:space="preserve">
    <value>命令补全建议的设置。
只在使用“vt100_24bit”颜色模式时才可自定义颜色。</value>
  </data>
  <data name="Console.CommandSuggestion.Enable" xml:space="preserve">
    <value>是否在控制台中显示命令建议。</value>
  </data>
  <data name="Console.CommandSuggestion.Use_Basic_Arrow" xml:space="preserve">
    <value>如果命令建议中的箭头未在您的终端中正确显示，请启用此选项。</value>
  </data>
  <data name="Console.General.ConsoleColorMode" xml:space="preserve">
    <value>使用“disable”、“legacy_4bit”、“vt100_4bit”、“vt100_8bit”或“vt100_24bit”。如果终端上出现“←[0m”等乱码，您可以尝试切换到“legacy_4bit”模式，或者直接禁用它。</value>
  </data>
  <data name="Console.General.Display_Input" xml:space="preserve">
    <value>您可以使用“Ctrl+P”打印当前输入和光标位置。</value>
  </data>
  <data name="Head" xml:space="preserve">
    <value>启动配置文件
请不要在此文件中记录任何无关的东西，因为这个文件会被MCC覆盖写入。

对 MCC（Minecraft 命令行客户端）不熟悉？请看这个文档：https://mccteam.github.io/g/conf.html
想升级到较新的版本吗？请访问 https://github.com/MCCTeam/Minecraft-Console-Client/#download</value>
  </data>
  <data name="Logging" xml:space="preserve">
    <value>此项设置仅会影响到控制台中的信息（日志）。</value>
  </data>
  <data name="Logging.ChatFilter" xml:space="preserve">
    <value>过滤聊天消息所用的正则表达式。</value>
  </data>
  <data name="Logging.ChatMessages" xml:space="preserve">
    <value>是否显示来自服务器的聊天消息。</value>
  </data>
  <data name="Logging.DebugFilter" xml:space="preserve">
    <value>过滤调试消息所用的正则表达式。</value>
  </data>
  <data name="Logging.DebugMessages" xml:space="preserve">
    <value>请在提交错误报告之前先启用此项。谢谢！</value>
  </data>
  <data name="Logging.ErrorMessages" xml:space="preserve">
    <value>显示错误消息。</value>
  </data>
  <data name="Logging.FilterMode" xml:space="preserve">
    <value>过滤方式："disable"（禁用），"blacklist"（隐藏匹配的消息） 或 "whitelist"（仅显示匹配的消息）</value>
  </data>
  <data name="Logging.InfoMessages" xml:space="preserve">
    <value>信息性的消息。（大部分来自MCC内部）</value>
  </data>
  <data name="Logging.LogFile" xml:space="preserve">
    <value>日志文件名称。</value>
  </data>
  <data name="Logging.LogToFile" xml:space="preserve">
    <value>是否将日志信息写入到文件。</value>
  </data>
  <data name="Logging.PrependTimestamp" xml:space="preserve">
    <value>写入日志文件时是否添加时间戳。</value>
  </data>
  <data name="Logging.SaveColorCodes" xml:space="preserve">
    <value>是否保留消息中的颜色字符。（例如"§b"）</value>
  </data>
  <data name="Logging.WarningMessages" xml:space="preserve">
    <value>显示警告消息。</value>
  </data>
  <data name="Main.Advanced" xml:space="preserve">
    <value>在更改这里的某项设置之前，请确保你理解了该选项的影响。</value>
  </data>
  <data name="Main.Advanced.account_list" xml:space="preserve">
    <value>AccountList：使你可以不用输入账号信息而快速在多个账号间切换
可用命令示例："/tell &lt;mybot&gt; reco Player2"，"/connect &lt;serverip&gt; Player1"</value>
  </data>
  <data name="Main.Advanced.auto_respawn" xml:space="preserve">
    <value>死亡时自动重生（开启前请确保你的出生点是安全的）</value>
  </data>
  <data name="Main.Advanced.bot_owners" xml:space="preserve">
    <value>设置机器人的所有者。/!\服务器管理员可以伪装成任何玩家!</value>
  </data>
  <data name="Main.Advanced.brand_info" xml:space="preserve">
    <value>客户端标识，可用 "mcc"，"vanilla"(原版客户端) 或 "none"(空标识)。这用于改变MCC向服务器发送的客户端标识内容。</value>
  </data>
  <data name="Main.Advanced.chatbot_log_file" xml:space="preserve">
    <value>留空将禁用 ChatBot 写入日志文件。</value>
  </data>
  <data name="Main.Advanced.enable_emoji" xml:space="preserve">
    <value>如果关闭，Emoji表情符号将被替换成更简单的字符（用于 "/chunk status" 命令）</value>
  </data>
  <data name="Main.Advanced.entity_handling" xml:space="preserve">
    <value>启用实体处理。</value>
  </data>
  <data name="Main.Advanced.exit_on_failure" xml:space="preserve">
    <value>发生错误时是否直接退出，用于在非交互式脚本中使用MCC。</value>
  </data>
  <data name="Main.Advanced.internal_cmd_char" xml:space="preserve">
    <value>MCC内部命令的前缀，可使用 "none", "slash"(/) 或 "backslash"(\)。</value>
  </data>
  <data name="Main.Advanced.inventory_handling" xml:space="preserve">
    <value>启用库存处理（可操作背包、箱子等容器）。</value>
  </data>
  <data name="Main.Advanced.language" xml:space="preserve">
    <value>请使用Minecraft语言代码填写，详见 https://mccteam.github.io/r/l-code.html</value>
  </data>
  <data name="Main.Advanced.LoadMccTrans" xml:space="preserve">
    <value>在可用时加载应用于MCC的翻译，关闭则仅使用英语。</value>
  </data>
  <data name="Main.Advanced.mc_forge" xml:space="preserve">
    <value>可使用 "auto"(自动)，"no"(禁用) 或是 "force"(强制启用，仅在 1.13 及更高的版本中可用)。</value>
  </data>
  <data name="Main.Advanced.mc_version" xml:space="preserve">
    <value>游戏版本，可使用 "auto"(自动) 或类似 "1.X.X" 的值。设定具体版本将跳过从服务器解析的过程。</value>
  </data>
  <data name="Main.Advanced.message_cooldown" xml:space="preserve">
    <value>控制向服务器发送消息的最小间隔时间（秒）。</value>
  </data>
  <data name="Main.Advanced.minecraft_realms" xml:space="preserve">
    <value>启用对加入我的世界领域(Realms)服务器的支持。</value>
  </data>
  <data name="Main.Advanced.MinTerminalHeight" xml:space="preserve">
    <value>当使用终端高度来计算显示的图像大小时，限制其最小高度。</value>
  </data>
  <data name="Main.Advanced.MinTerminalWidth" xml:space="preserve">
    <value>当使用终端宽度来计算显示的图像大小时，限制其最小宽度。</value>
  </data>
  <data name="Main.Advanced.movement_speed" xml:space="preserve">
    <value>高于 2 的移动速度可能会被检测为作弊。</value>
  </data>
  <data name="Main.Advanced.move_head_while_walking" xml:space="preserve">
    <value>在移动时转向头部。</value>
  </data>
  <data name="Main.Advanced.player_head_icon" xml:space="preserve">
    <value>使用玩家皮肤头像作为窗口图标，这仅在部分旧版控制台中有效。</value>
  </data>
  <data name="Main.Advanced.private_msgs_cmd_name" xml:space="preserve">
    <value>远程控制功能将会使用它。</value>
  </data>
  <data name="Main.Advanced.profilekey_cache" xml:space="preserve">
    <value>如何缓存聊天签名密钥。可使用 "none"(不缓存)，"memory"(内存缓存) 或 "disk"(磁盘缓存)。</value>
  </data>
  <data name="Main.Advanced.resolve_srv_records" xml:space="preserve">
    <value>可填写 "no"，"fast"（超时时间为五秒钟）或是 "yes"。加入某些服务器需要开启此项。</value>
  </data>
  <data name="Main.Advanced.script_cache" xml:space="preserve">
    <value>缓存已编译的脚本，以便在低端设备上更快的加载。</value>
  </data>
  <data name="Main.Advanced.server_list" xml:space="preserve">
    <value>ServerList：可用使用服务器别名快速连接到该服务器
别名不能包含空格和小数点"，而且 "localhost" 不能作为别名使用。
可用命令示例："/tell &lt;mybot&gt; connect Server1"，"/connect Server2"</value>
  </data>
  <data name="Main.Advanced.session_cache" xml:space="preserve">
    <value>如何缓存会话令牌。可使用 "none"(不缓存)，"memory"(内存缓存) 或 "disk"(磁盘缓存)。</value>
  </data>
  <data name="Main.Advanced.show_chat_links" xml:space="preserve">
    <value>解码聊天信息里的链接，并在控制台单独显示。</value>
  </data>
  <data name="Main.Advanced.show_inventory_layout" xml:space="preserve">
    <value>以字符画形式显示库存布局。</value>
  </data>
  <data name="Main.Advanced.show_system_messages" xml:space="preserve">
    <value>显示游戏服务器的系统消息（来自管理员或命令方块等）。</value>
  </data>
  <data name="Main.Advanced.show_xpbar_messages" xml:space="preserve">
    <value>显示经验条上方的消息，如果被此类消息刷屏请禁用此选项。</value>
  </data>
  <data name="Main.Advanced.temporary_fix_badpacket" xml:space="preserve">
    <value>暂时修复一些服务器上的坏数据包问题。需要先启用“TerrainAndMovements”。</value>
  </data>
  <data name="Main.Advanced.terrain_and_movements" xml:space="preserve">
    <value>开启地形处理将消耗更多的内存、CPU和网络带宽，但这允许你进行移动以及和方块交互。</value>
  </data>
  <data name="Main.Advanced.timeout" xml:space="preserve">
    <value>与服务器的TCP连接超时时间（秒）。</value>
  </data>
  <data name="Main.Advanced.timestamps" xml:space="preserve">
    <value>在聊天信息头部添加时间戳。</value>
  </data>
  <data name="Main.General.account" xml:space="preserve">
    <value>Login请填写邮箱或玩家名称。若要以离线模式登录请使用"-"作为密码。若留空则使用交互式登录。</value>
  </data>
  <data name="Main.General.login" xml:space="preserve">
    <value>游戏服务器的地址和端口，可填入域名或IP地址。（可删除端口字段，会自动解析SRV记录）</value>
  </data>
  <data name="Main.General.method" xml:space="preserve">
    <value>微软账户的登录方式：mcc 或是 browser（手动在网页上登录）。</value>
  </data>
  <data name="Main.General.server_info" xml:space="preserve">
    <value>帐户类型：mojang 或是 microsoft 或是 yggdrasil。此项设置也会影响交互式登录。</value>
  </data>
  <data name="MCSettings" xml:space="preserve">
    <value>下面的设置将会被发送到游戏服务器，只影响一些服务器端的东西，比如你的皮肤。</value>
  </data>
  <data name="MCSettings.ChatColors" xml:space="preserve">
    <value>这允许你在服务器端禁用聊天颜色。</value>
  </data>
  <data name="MCSettings.ChatMode" xml:space="preserve">
    <value>使用 "enabled"（完全启用聊天）、"commands"（仅限命令）或 "disabled"（完全禁用聊天）。这允许你禁言自己...</value>
  </data>
  <data name="MCSettings.Difficulty" xml:space="preserve">
    <value>Minecraft 1.7及更早版本难度。"peaceful"，"easy"，"normal"，"difficult"。</value>
  </data>
  <data name="MCSettings.Enabled" xml:space="preserve">
    <value>如果禁用，下面的设置就不会被发送到服务器上。</value>
  </data>
  <data name="MCSettings.Locale" xml:space="preserve">
    <value>请使用Minecraft的语言代码填写，详见[Main.Advanced.Language]</value>
  </data>
  <data name="MCSettings.MainHand" xml:space="preserve">
    <value>在1.9及更高版本中的主手设置。"left"（左手） 或 "right"（右手）。</value>
  </data>
  <data name="MCSettings.RenderDistance" xml:space="preserve">
    <value>渲染距离，取值范围[0 - 255]。</value>
  </data>
  <data name="Proxy" xml:space="preserve">
    <value>通过代理连接到服务器。
如果Mojang/微软登录服务被防火墙阻断，设置Enabled_Login=true以使用代理进行登录。
如果到Minecraft游戏服务器的连接被防火墙阻止，设置Enabled_Ingame=true以使用代理连接游戏服务器。
/!\ 在启用代理前，请确保你的服务器规则允许使用代理或VPN，否则你可能面临被封禁等风险！</value>
  </data>
  <data name="Proxy.Enabled_Ingame" xml:space="preserve">
    <value>是否通过代理连接Minecraft游戏服务器。</value>
  </data>
  <data name="Proxy.Enabled_Login" xml:space="preserve">
    <value>是否使用代理连接Mojang或微软的登录服务器。</value>
  </data>
  <data name="Proxy.Enabled_Update" xml:space="preserve">
    <value>下载MCC的更新时是否通过代理服务器。</value>
  </data>
  <data name="Proxy.Password" xml:space="preserve">
    <value>只有连接到受密码保护的代理才需要。</value>
  </data>
  <data name="Proxy.Proxy_Type" xml:space="preserve">
    <value>支持的代理类型："HTTP"，"SOCKS4"，"SOCKS4a"，"SOCKS5"。</value>
  </data>
  <data name="Proxy.Server" xml:space="preserve">
    <value>代理服务器必须允许HTTPS登录。</value>
  </data>
  <data name="Proxy.Username" xml:space="preserve">
    <value>只有连接到受密码保护的代理才需要。</value>
  </data>
  <data name="Signature" xml:space="preserve">
    <value>聊天签名相关设置（影响1.19及以上版本）</value>
  </data>
  <data name="Signature.LoginWithSecureProfile" xml:space="preserve">
    <value>仅微软账户可用。如禁用此项，将无法签名消息和进入某些的服务器。</value>
  </data>
  <data name="Signature.MarkIllegallySignedMsg" xml:space="preserve">
    <value>是否使用红色色块标识没有合法签名的聊天。</value>
  </data>
  <data name="Signature.MarkLegallySignedMsg" xml:space="preserve">
    <value>是否使用绿色色块标识拥有合法签名的聊天。</value>
  </data>
  <data name="Signature.MarkModifiedMsg" xml:space="preserve">
    <value>是否使用黄色色块标识被服务器更改过的聊天。</value>
  </data>
  <data name="Signature.MarkSystemMessage" xml:space="preserve">
    <value>是否使用灰色色块标识系统消息（它们总是不会被签名）。</value>
  </data>
  <data name="Signature.ShowIllegalSignedChat" xml:space="preserve">
    <value>是否显示没有被正确签名的聊天消息。</value>
  </data>
  <data name="Signature.ShowModifiedChat" xml:space="preserve">
    <value>设置为 true，显示被服务器修改过的信息；设置为 false，显示经过签名的原始信息。</value>
  </data>
  <data name="Signature.SignChat" xml:space="preserve">
    <value>是否签名发送的聊天消息。</value>
  </data>
  <data name="Signature.SignMessageInCommand" xml:space="preserve">
    <value>是否签名指令中的消息。例如"/msg"和"/me"中的消息。</value>
  </data>
  <data name="ChatBot.ItemsCollector.Collect_All_Item_Types" xml:space="preserve">
    <value>如果被设置为true，则机器人会拾取所有的掉落物，无论其类型如何。如果您需要使用掉落物白名单，请将该选项设置为false。</value>
  </data>
  <data name="ChatBot.ItemsCollector.Items_Whitelist" xml:space="preserve">
    <value>在这个列表中，您可以指定机器人要有目标地拾取某些掉落物。要启用该选项，请将Collect_All_Item_Types设为false。（PS：这并不能阻止机器人意外地拾取其他掉落物，它只是前往它发现掉落物的位置。）\n您可以参照掉落物类型列表：https://raw.githubusercontent.com/MCCTeam/Minecraft-Console-Client/master/MinecraftClient/Inventory/ItemType.cs</value>
  </data>
  <data name="ChatBot.ItemsCollector.Delay_Between_Tasks" xml:space="preserve">
    <value>机器人扫描掉落物的延迟，以毫秒为单位。（推荐：300~500ms左右）</value>
  </data>
  <data name="ChatBot.ItemsCollector.Collection_Radius" xml:space="preserve">
    <value>机器人搜寻掉落物的半径。（默认：30格）</value>
  </data>
  <data name="ChatBot.ItemsCollector.Always_Return_To_Start" xml:space="preserve">
    <value>如果您将其设置为true，则机器人会在拾取完所有掉落物后返回起始位置。</value>
  </data>
  <data name="ChatBot.ItemsCollector.Prioritize_Clusters" xml:space="preserve">
    <value>如果设置为 true，机器人将会在收集完所有物品之后处理，而不是收集一次就处理</value>
  </data>
  <data name="ChatBot.ItemsCollector" xml:space="preserve">
    <value>一个收集掉落物的Chat Bot。</value>
  </data>
  <data name="ChatBot.WebSocketBot" xml:space="preserve">
    <value>通过Web Sockets来远程控制MCC机器人.\n# 在远程和异步执行MCC中的程序很有用.\n# JavaScript示例: https://github.com/milutinke/MCC.js.git\n# 协议规范很快将会在文档种提供</value>
  </data>
  <data name="ChatBot.WebSocketBot.Ip" xml:space="preserve">
    <value>WebSocket服务器监听的IP地址</value>
  </data>
  <data name="ChatBot.WebSocketBot.Port" xml:space="preserve">
    <value>Websocket服务器绑定的端口</value>
  </data>
  <data name="ChatBot.WebSocketBot.Password" xml:space="preserve">
    <value>密码会用于Web Socket服务器的身份验证（建议修改默认密码并设置一个强密码）</value>
  </data>
  <data name="ChatBot.WebSocketBot.DebugMode" xml:space="preserve">
    <value>此选项适用于使用Chat Bot远程执行程序/命令/函数</value>
  </data>
  <data name="ChatBot.WebSocketBot.AllowIpAlias" xml:space="preserve">
    <value>允许 IP 别名，如 "localhost"；如果使用容器，则可以使用容器名称...</value>
  </data>
  <data name="Main.Advanced.ignore_invalid_playername" xml:space="preserve">
    <value>忽略无效的玩家名</value>
  </data>
  <data name="Main.General.AuthlibServer" xml:space="preserve">
    <value>Yggdrasil API 认证服务器的域名与端口。</value>
  </data>
</root>